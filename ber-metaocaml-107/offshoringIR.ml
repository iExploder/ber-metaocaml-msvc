(* Converting a simple subset of OCaml to an intermediate language 
   designed to be easily translatable to C, openCL, LLVM, etc.

   We handle only an (imperative) subset of OCaml, as typical in offshoring.
*)

(* We take advantage of the fact that the our OCaml source is presumed
   to have been generated by MetaOCaml: All identifiers
   have unique names and all types are fully qualified.
*)

(* Simple OCaml code may be considered as C written in different syntax.
   The following helps bring OCaml closer to C
   The OCaml implementation is there to make the code run in OCaml,
   for testing. The C translation will look at the names themeselves,
   as `float32', 'forloop', etc.
#directory "+compiler-libs";;
*)

type float32 = float

let float32_of_float : float -> float32 = fun x -> x

(* For-loop with a step, like the for-loop in C (upper bound is exclusive) *)
let forloop : int -> int -> int -> (int -> unit) -> unit =
 fun lwb upb step body ->
   let rec loop i = if i >= upb then () else (body i; loop (i+step))
   in loop lwb


(* Types that we currently support
   It is a subset of the very simplified OCaml type representation
   It is much easier to deal with than OCaml compiler type representation
*)

type typ = ..
type typ +=
  | TUnit
  | TInt
  | TBool
  | TFloat                              (* 32-bit *)
  | TDouble                             (* 64-bit *)
  | TArray1 of typ                      (* Usual array or Bigarray.Array1 *)
  | TArray2 of typ                      (* Bigarray.Array2 *)
  | TRef of typ
  | TVariable                           (* sometimes inevitably occurs
                                           We do not do any substitutions, etc*)
		 
(* We don't timestamp the variable names since MetaOCaml already
   renamed all the identifiers
*)
type varname = string 
		 
(* The AST of the intermediate language (IR)
   It reflects the simple subset of OCaml that we handle *)

type attribute = ..
type constant_t = Asttypes.constant

type exp =
  | Const    of Asttypes.constant       (* Constant/literal: int, bool,...*)
  | LocalVar of varname * typ           (* Locally-bound variable *)
  | KnownVar of varname                 (* Global/library function,... *)
  | FunCall  of varname * exp list      (* Calls only to known identifiers *)
  | Let      of {id: varname; ty: typ; bind: exp; body: exp;
                 attrs: attribute list}
  | IfE      of exp * exp * exp
 and cmd =
  | FunCallC of varname * exp list      (* Calls only to known identifiers *)
  | LetC      of {id: varname; ty: typ; bind: exp; body: cmd;
                 attrs: attribute list}
  | If       of exp * cmd * cmd option
  | For      of {id: varname; ty:typ;
                 lwb: exp; upb: exp; step: exp; body: cmd}
  | While    of exp * cmd 
  | Seq      of cmd * cmd
 
(* User-defined converters-helpers *)
module type converters = sig
  type pathname = string                (* a fully-qualified name *)
  (* Convert a type, with the head constructor of the given qualified
     name and the given parameters
   *)
  val type_conv : pathname -> typ list -> typ
  (* Convert a qualified id, given the module path and the name,
     into something that, say, a C code generator may use for a name.
     Some module names like Opencl may be known to the C generator
     and treated specially.
   *)
  val id_conv : pathname -> varname -> string
end

(* Convert an OCaml type to the simpler representation typ,
   raising exception on the types we do not handle
*)
			
let typ_of : (module converters) -> Types.type_expr -> Env.t -> typ 
 = fun (module Conv) typ env ->
  let open Types in
  let typ = Ctype.correct_levels typ in
  let rec loop typ =
    let exp_ty = Ctype.expand_head env typ in
    match Ctype.repr exp_ty with
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_unit ->
        TUnit
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_int ->
        TInt
    (*
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_char ->
        "char" *)
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_bool ->
        TBool
    | {desc = Tconstr(p, _, _)} when Path.same p Predef.path_float ->
        TDouble
    | {desc = Tconstr(p, [t], _)} when Path.same p Predef.path_array ->
        TArray1 (loop t)
    | {desc = Tconstr(p, [t;_;_], _)} when 
           Path.name p = "Bigarray.Array1.t" ->
             TArray1 (loop t)
    | {desc = Tconstr(p, [t;_;_], _)} when 
           Path.name p = "Bigarray.Array2.t" ->
             TArray2 (loop t)
    | {desc = Tconstr (p,[t], _)} when Path.name p = "Stdlib.ref" ->
        TRef (loop t)
    | {desc = Tconstr (p,[], _)} when Path.name p = "OffshoringIR.float32" ->
        TFloat
    | {desc = Tconstr (p,ts, _)} ->
        Conv.type_conv (Path.name p) (List.map loop ts)
    | {desc = Tvar _} -> TVariable
    | _ -> 
       let open Format in
       fprintf str_formatter "typ_of: the OCaml type %a is (not yet) supported"
               Printtyp.type_expr typ;
       failwith @@ flush_str_formatter ()
  in loop typ
	  

(* Alas, Printtyped only exports functions for printing structures and
   signatures. If we want to print and expression, we have to wrap it
   into a signature
*)
let print_texp : Format.formatter -> Typedtree.expression -> unit =
  fun ppf exp ->
   let open Typedtree in
   let stru = 
    {str_items =
      [{str_desc = Tstr_eval(exp,[]);
        str_loc  = exp.exp_loc;
        str_env  = exp.exp_env}];
     str_type = [];
     str_final_env = exp.exp_env}
    in
    Printtyped.implementation ppf stru

(* Report an expression we aren't handling *)
let fail_exp : string -> Typedtree.expression -> 'a = fun msg exp ->
   let open Format in
   let _ = fprintf str_formatter "%s: @,%a@." msg print_texp exp in
   failwith @@ flush_str_formatter ()

(* Handle the top-level function and determine its arguments and their types *)

let analyze_function: 
    (module converters) ->
    Typedtree.expression -> 
      (varname * typ) list *            (* arguments names and types *)
      typ *                             (* the type of the result *)
      Typedtree.expression =            (* the function body *)
  fun conv ->
  let open Typedtree in
  let open Asttypes in
  let rec loop acc = function       
    | { Typedtree.exp_desc = 
        Texp_function{arg_label=Nolabel;
                      cases=[
                        {c_lhs = 
                         {pat_desc =Tpat_var (x,_); 
                          pat_type=typ; pat_env=env};
                         c_guard = None;
                         c_rhs   = body}]}} -> 
        loop ((Ident.name x,typ_of conv typ env)::acc) body
    | { Typedtree.exp_desc = Texp_function _ } as e ->
        fail_exp "the code is not a simple function" e
    | e when acc = [] -> fail_exp "the code is not a simple function" e
    | e ->
        let tp = e.exp_type and env = e.exp_env in
        (List.rev acc, typ_of conv tp env, e)
  in loop []


(* Convert from the full OCaml AST to the simplified subset *)

(* Classify an identifier *)
type id_class = 
    | Known of varname                 (* Global function, variable, etc *)
    | Local of varname                 (* Locally bound variable *)

let class_of_path : (module converters) -> Path.t -> id_class = 
  let open Path in
  fun (module Conv) -> function
  | Pdot (Pident p, x, _) when
         Ident.name p = "Stdlib" &&
	 List.mem x ["+";"-";"*";"/";"+.";"-.";"*.";"/.";":=";"ref";"!"] ->
     Known x
  | Pdot (p,"get",_) when Path.name p = "Stdlib.Array" ->
     Known "array1_get"
  | Pdot (p,"set",_) when Path.name p = "Stdlib.Array" ->
     Known "array1_set"
  | Pdot (p,"get",_) when Path.name p = "Bigarray.Array1" ->
     Known "array1_get"
  | Pdot (p,"set",_) when Path.name p = "Bigarray.Array1" ->
     Known "array1_set"
  (*
  | Pdot (p,"get",_) when Ident.name p = "Bigarray.Array2" ->
     Known "array2_get"
  *)
  | Pdot (p,"forloop",_) when Path.name p = "OffshoringIR" ->
     Known "forloop"
  (* Ask the user *)  
  | Pdot (p, x, _) -> Known (Conv.id_conv (Path.name p) x)
  | Pident x       -> Local (Ident.name x)
  | p -> failwith @@ "class_of_path unknown id: " ^ Path.name p


let rec exp_of : (module converters) -> Typedtree.expression -> exp = 
 fun ((module Conv) as conv) e ->
  let open Typedtree in 
  let open Asttypes in 
  let tp = e.exp_type and env = e.exp_env in
  match e.exp_desc with
  | Texp_ident (p,_,_) -> begin
      match class_of_path conv p with
      | Known x -> KnownVar x
      | Local x -> LocalVar (x, typ_of conv tp env)
      end
  | Texp_constant x -> Const x
  (* Get rid of @@ and replace with the ordinary application *)
  | Texp_apply ({exp_desc = Texp_ident (p,_,_)},
                [(Nolabel, Some e1);e2]) when Path.name p = "Stdlib.@@" ->
    begin
      match e1 with
      | {exp_desc = Texp_apply (e11,args)} ->
           exp_of conv {e with exp_desc = Texp_apply (e11,args @ [e2])}
      | _ -> exp_of conv {e with exp_desc = Texp_apply (e1,[e2])}
    end

  (* General application *)
  | Texp_apply (eo,args) ->
      let op = match exp_of conv eo with
      | KnownVar x -> x
      | _  -> fail_exp "Only calls to global functions are not allowed" e
      in
      let args = List.map (function 
        | (Nolabel,Some e) -> exp_of conv e
        | _ -> fail_exp "unsupported labeled or default args" e) args in
      FunCall (op,args)
  | Texp_let (Nonrecursive,
               [{vb_pat=
                 {pat_desc =Tpat_var (x,_);pat_type;pat_env};
                 vb_expr}],body)
    -> Let {id=Ident.name x; ty=typ_of conv pat_type pat_env;
            bind=exp_of conv vb_expr; body=exp_of conv body;
            attrs=[]}
  | Texp_ifthenelse (etest,eth,Some eel) ->
      IfE (exp_of conv etest, exp_of conv eth, exp_of conv eel)
  | _ -> fail_exp "unhandled expression" e
 and 
 cmd_of : (module converters) -> Typedtree.expression -> cmd = 
 fun ((module Conv) as conv) e ->
  let open Typedtree in 
  let open Asttypes in 
  let tp = e.exp_type and env = e.exp_env in
  assert (typ_of conv tp env = TUnit);
  match e.exp_desc with
  (* Special applications *)
  | Texp_apply (e,
                [(Nolabel,Some lwb);(Nolabel,Some upb);(Nolabel,Some step);
                 (Nolabel,Some {exp_desc = 
                  Texp_function 
                       {arg_label=Nolabel;
                        cases = [
                         {c_lhs = 
                           {pat_desc =Tpat_var (x,_);
                            pat_env;pat_type};
                          c_guard = None;
                          c_rhs   = body}]}})])
    when
      exp_of conv e = KnownVar "forloop" ->
        For {id=Ident.name x; ty=typ_of conv pat_type pat_env;
             lwb=exp_of conv lwb;
             upb=exp_of conv upb;
             step=exp_of conv step;
             body=cmd_of conv body}
  | Texp_apply _ -> begin
      match exp_of conv e with
      | FunCall (op,args) -> FunCallC (op,args)
      | _ -> assert false
  end
  | Texp_for (x,_,elow,ehigh,Upto,body) ->
      let one = Const (Const_int 1) in
      (* Make the upper bound exclusive *)
      let upb = match exp_of conv ehigh with
      | FunCall ("-", [x;one']) when one'=one -> x
      | x -> FunCall ("+",[one;x]) in
      For {id=Ident.name x; ty=TInt;
             lwb=exp_of conv elow;
             upb;
             step=one;
             body=cmd_of conv body}
  | Texp_while (et,body) ->
      While (exp_of conv et, cmd_of conv body)
  | Texp_ifthenelse (etest,eth,None) ->
      If (exp_of conv etest, cmd_of conv eth, None)
  | Texp_ifthenelse (etest,eth,Some eel) ->
      If (exp_of conv etest, cmd_of conv eth, Some (cmd_of conv eel))
  | Texp_sequence(e1,e2) ->
      Seq (cmd_of conv e1, cmd_of conv e2)
  | Texp_let (Nonrecursive,
               [{vb_pat=
                 {pat_desc =Tpat_var (x,_);pat_type;pat_env};
                 vb_expr}],body)
    -> LetC {id=Ident.name x; ty=typ_of conv pat_type pat_env;
             bind=exp_of conv vb_expr; body=cmd_of conv body;
             attrs=[]}
  | _ -> fail_exp "unhandled command" e

(* Default conversion module. The programmer is supposed to
   include it and override what is needed
*)
module DefaultConv : converters = struct
  type pathname = string                (* a fully-qualified name *)
  let type_conv : pathname -> typ list -> typ = fun path _args ->
    failwith @@ "Unknown type: " ^ path
  (* Convert a qualified id, given the module path and the name,
     into something that, say, a C code generator may use for a name.
     Some module names like Opencl may be known to the C generator
     and treated specially.
   *)
  let id_conv : pathname -> varname -> varname = fun path name ->
    failwith @@ "Don't know what to do with " ^ path ^ "." ^ name
end

(* Main offshoring function: convert from the code in the supported 
   subset of OCaml to the intermediate language.
   Return either cmd (for procedure with no result) or exp and the
   result type.
*)
type args_t = (varname * typ) list
type proc_t = 
  | Fun  of args_t * typ * exp           (* Function with the result *)
  | Proc of args_t * cmd                 (* Procedure, no result     *)
let offshore : (module converters) -> 'a Codelib.code -> proc_t = 
 fun conv cde ->
  let (args,typ,body) = 
    analyze_function conv @@
    Runcode.typecheck_code @@ Codelib.close_code cde
  in
  if typ = TUnit then Proc (args, cmd_of conv body)
      else Fun (args, typ, exp_of conv body)



